<!DOCTYPE html>
<html lang="en">
<head>
	<title>JS FE</title> 
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1"> 
</head>
<body>
	Hello world!



<script>

// objects

let numbers = {
	a: 5,
	b: 7,
	c: 8, 
	d: 2,
	e: 4,
	f: 3,
	g: 'admin',
	h: [1,2,3],
	i: {
		n: 4,
		m: 5
	}
}

// obj to arr

function numsFromObjToArr(obj, array = [], i = 0){
	let arr = array;
	let index = i;
	for(let prop in obj){
		if(typeof obj[prop] == 'number'){
			arr[index] = obj[prop];
			index++;
		}
		else if(typeof obj[prop] == 'object' && obj[prop].length > 0){
			for(let data of obj[prop]){
				if(typeof data == 'number'){
					arr[index] = data;
					index++;
				}
			}
		}
		else if(typeof obj[prop] == 'object' && obj[prop].length == undefined){ // нашли вложенный обьект и вызываем рекурсивно numsFromObjToArr
			numsFromObjToArr(obj[prop], arr, index);
		}
	}
	return arr;
}

console.log(numsFromObjToArr(numbers));


// HW 1) допилить функцию numsFromObjToArr, чтобы она могла находить числа внутри дочерних обьектов или массивов


//2 

//({ a: 1, b: 2 }) => [['a', 1], ['b', 2]]

function objectToArray(obj){
	let arr = [];
	let index = 0;

	for(let prop in obj){
		let innerArr = [];
		innerArr[0] = prop;
		innerArr[1] = obj[prop];

		arr[index] = innerArr;
		index++;
	}

	return arr;
}


console.log(objectToArray({ a: 1, b: 2 , c: 3, d: 4}));


// 3

//({ a: 1, b: 2 }, 'b') => { a: 1 }

let o1 = { a: 1, b: 2};
let o2 = { a: 1, b: 2 , c: 3, d: 4};

function excludeFromObject(obj){
	// mutable
	// for(let prop in obj){
	// 	for(let prop in obj){
	// 		for(let i = 1; i < arguments.length; i++){ // все параметры функции, которые пришли после обьекта (arguments[0]) - это то, что нужно удалить
	// 			if(prop === arguments[i]){
	// 				delete obj[prop];
	// 			}
	// 		}
	// 	}
	// }
	// return obj;

	// better immutable version will use array methods

	let newObj = {};
	for(let prop in obj){
		newObj[prop] = obj[prop];
	}
	for(let prop in newObj){
		for(let prop in newObj){
			for(let i = 1; i < arguments.length; i++){ // все параметры функции, которые пришли после обьекта (arguments[0]) - это то, что нужно удалить
				if(prop === arguments[i]){
					delete newObj[prop];
				}
			}
		}
	}
	return newObj;

}

console.log(excludeFromObject(o1, 'b'));
console.log(excludeFromObject(o2, 'b', 'c'));


//4 

function isEmpty(obj){
	let objectIsEmpty = true;
	for(let prop in obj){
		if(obj[prop] !== undefined){
			objectIsEmpty = false;
		}
	}
	console.log(objectIsEmpty);
}

isEmpty({});
isEmpty({a: undefined});
isEmpty({a: undefined, b: undefined, c: undefined, d: 1});
isEmpty({a: 1});

// 5

function equalObjects(obj1, obj2){
	let objectsAreEqual = true;
	for(let prop in obj1){
		if(!prop in obj2 || obj2[prop] !== obj1[prop]){ // если во втором обьекте нет такого свойства или значение свойства в обьекте2 отличается от значения в обьекте1
			objectsAreEqual = false;
		}
	}
	// второй раз мы проходим циклом по второму обьекту на случай, если в нем было больше свойств
	for(let prop in obj2){
		if(!prop in obj1 || obj2[prop] !== obj1[prop]){ // если во первом обьекте нет такого свойства или значение свойства в обьекте2 отличается от значения в обьекте1
			objectsAreEqual = false;
		}
	}
	return objectsAreEqual;
}


console.log(equalObjects({ a: 1, b: 1 }, { a: 1, b: 1 }));
console.log(equalObjects({ a: 1, b: 1, c: 1 }, { a: 1, b: 1 }));
console.log(equalObjects({ a: 1, b: 1 }, { a: 1, b: 1, c: 1 }));
console.log(equalObjects({ a: 1, b: 1, c: 2 }, { a: 1, b: 1, c: 1 }));

</script>

</body>
</html>