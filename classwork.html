<!DOCTYPE html>
<html lang="en">
<head>
	<title>JS FE</title> 
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1"> 
</head>
<body>
	Hello world!



<script>

// 1) Напишите функцию map(fn, array), которая принимает на вход функцию и массив, и обрабатывает каждый элемент массива этой функцией, возвращая новый массив.  

function map(fn, array){
	let newArr = [];
	for(let n of array){
		newArr.push(fn(n));
	}
	return newArr;
}

function square(num){
	return num * num;
}

console.log(map(square, [2,3,4,5]));

// 2) Описание задачи: Напишите функцию, которая поверхностно находит пересечения объектов и возвращает объект пересечений. 
// Ожидаемый результат: ({ a: 1, b: 2 }, { c: 1, b: 2 }) => { b: 2 }

function intersection(o1, o2){
	let inter = {};

	let length1 = objLength(o1);
	let length2 = objLength(o2);

	let target = length1 > length2 ? o1 : o2;
	let smaller = length1 > length2 ? o2 : o1;

	for(let prop in target){
		if(smaller[prop] === target[prop]){
			inter[prop] = target[prop];
		}
	}
	console.log(inter);
}

intersection({ a: 1, b: 2 }, { c: 1, b: 2 });
intersection({ b: 2, c: 3, d: 4 }, { a: 1, b: 2, c: 3, d: 4, e: 5 });


// 3)Напишите функцию, считающую число свойств в объекте и записывающую его как length (length не итерируемый)

function objLength(obj){
	let count = 0;

	for(let prop in obj){
		count++
	}

	Object.defineProperty(obj, 'length', {
		value: count,
		enumerable: false,
		writable: false,
		configurable: true
	});
	return count;
}
let user = {
	name: 'John',
	age: 22
}
console.log(objLength(user));

// 4)  Дан массив с числами. Выведите последовательно его элементы используя рекурсию и не используя цикл. (при решении использовать методы массивов)

function printArray(array){
	if(array.length > 0){
		console.log(array.shift());
		printArray(array);
	}
}

printArray([1,2,3,4,5]);

// 5) Допустим, вы написали рассказ, и везде для обозначения диалогов использовали одинарные кавычки. 
// Теперь вы хотите заменить кавычки диалогов на двойные, и оставить одинарные в сокращениях слов типа aren’t.
// Придумайте шаблон, различающий два этих использования кавычек, и напишите вызов метода replace, который производит замену.

function extendedReplace(str){
	let newstr = str.replace(/\'/g, '"');
	newstr = newstr.replace(/(?<=[a-z])\"(?=[a-z])/g, `'`);
	console.log(newstr);
}

extendedReplace(`'The weather is charming' - said Moomin. 
'Yes, soon will start snowing. Let's go' - answered Snoopkin. 
'Aren't we going?' - asked Moomin`);

// 6) У массивов есть ещё стандартные методы every и some. Они принимают как аргумент некую функцию, которая, будучи вызванной с элементом массива в качестве аргумента, возвращает true или false. 
//Так же, как && возвращает true, только если выражения с обеих сторон оператора возвращают true, метод every возвращает true, когда функция возвращает true для всех элементов массива. 
// Соответственно, some возвращает true, когда заданная функция возвращает true при работе хотя бы с одним из элементов массива. Они не обрабатывают больше элементов, чем необходимо – например, если some получает true для первого элемента, он не обрабатывает оставшиеся. 
// Напишите функции every и some, которые работают так же, как эти методы, только принимают массив в качестве аргумента.

function every(array, condition){
	let everyMatches = true;
	for(let item of array){
		if(!checkAge(item)){
			everyMatches = false;
			break;
		}
	}
	return everyMatches;
}

function some(array, condition){
	let someMatches = false;
	for(let item of array){
		if(checkAge(item)){
			someMatches = true;
			break;
		}
	}
	return 	someMatches;
;
}

function checkAge(age){
	return age >= 18;
}

console.log(every([12,14,16,18,20], checkAge));
console.log(every([22,18,20], checkAge));

console.log(some([12,14,16,18,20], checkAge));
console.log(some([12,11,10], checkAge));

// 7) Объекты могут быть использованы для построения различных структур данных. Часто встречающаяся структура – список (не путайте с массивом). Список – связанный набор объектов, где первый объект содержит ссылку на второй, второй – на третий, и т.п.
// Списки удобны тем, что они могут делиться частью своей структуры. Например, можно сделать два списка, {value: 0, rest: list} и {value: -1, rest: list}, где list – это ссылка на ранее объявленную переменную. Это два независимых списка, при этом у них есть общая структура list, которая включает три последних элемента каждого из них. Кроме того, оригинальный список также сохраняет свои свойства как отдельный список из трёх элементов.
// Напишите функцию arrayToList, которая строит такую структуру, получая в качестве аргумента [1, 2, 3], а также функцию listToArray, которая создаёт массив из списка. 
// Также напишите вспомогательную функцию prepend, которая получает элемент и создаёт новый список, где этот элемент добавлен спереди к первоначальному списку, 
//и функцию nth, которая в качестве аргументов принимает список и число, а возвращает элемент на заданной позиции в списке, или же undefined в случае отсутствия такого элемента.

// Если ваша версия nth не рекурсивна, тогда напишите её рекурсивную версию.

let list = {
  value: 1,
  rest: {
    value: 2,
    rest: {
      value: 3,
      rest: null
    }
  }
};

let arr = [1,2,3];

function arrayToList(array){
	let list = {};
	let currObj = list;
	array.forEach((item, index) => {
		let newObj = {
			value: item,
			rest: index < array.length - 1 ? {} : null
		}
		for(let prop in newObj){
			currObj[prop] = newObj[prop];
		}
		currObj = newObj.rest;
	});
	console.log(list);
}

function prepend(value, list){
	let newList = {
		value: value,
		rest: list
	}

	console.log(newList);
}

prepend(0, list);
prepend(-1, list);

arrayToList(arr);

function listToArray(obj, arr = []){
	arr.push(obj.value);
	if(obj.rest != null){
		return listToArray(obj.rest, arr);
	}
	else{
		return arr;
	}
}

console.log(listToArray(list));

function nth(obj, index){
	if(index > 0){
		if(obj.rest != null){
			return nth(obj.rest, index-1) ;
		}
		else{
			return undefined
		}
	}
	else{
		return obj.value ;
	}
}

console.log(nth(list, 1)); // 2
console.log(nth(list, 2)); // 3
console.log(nth(list, 6)); // 1


// api call to Instagram
// fatch user(kseniiabi)
let instauser = {
	name: 'kseniiabi',
	subscribersCount: 100,
	following: 100,
	subscribers: 
		[
			{
				name: 'anna111',
				subscribersCount: 100,
				following: 200,
				subscribers: [
					{
						name: 'nnn777'
					}
				]
			}
		]
	
}

// 8) Найти самое длинное слово в предложении. Результатом работы функции должна быть длина такого слова.

function findLongestWord(str){
	let modifiedStr = str.replace(/(\,|\.|\?|\-| '|' )/g, ' ');
	let arr = modifiedStr.split(' ');
	arr.sort((a,b) => {
		if(a.length > b.length){
			return -1;
		}
		else if(a.length < b.length){
			return 1;
		}
		else{
			return 0;
		}
	});
	console.log(arr);
	console.log(arr[0].length);
}

findLongestWord(`'The weather is charming' - said Moomin. 'Yes, soon will start snowing. Let's go' - answered Snoopkin. 'Aren't we going?' - asked Moomin`);

// 9) Преобразовать строку так, чтобы все буквы были в нижнем регистре за исключением первой буквы каждого слова. titleCase("sHoRt AnD sToUt") ⇒ Short And Stout

function titleCase(str){
	let arr = str.split(' ');
	let newstr = '';

	for(let word of arr){
		newstr += word.charAt(0).toUpperCase() + word.slice(1).toLowerCase() + ' ';
	}
	newstr = newstr.trim();
	console.log(newstr);
}

titleCase('sHoRt AnD sToUt');

// 10) Обрежьте данную строку str, если ее длина превосходит данное число num. Добавьте в конец обрезанной строки троеточие "...", если str более num. Заметим, что троеточие должно учитываться при проверке длины строки str.

// 11) Найти массив из наибольших чисел каждого из  подмассивов переданного массива.
// Пример: largestOfFour([[13, 27, 18, 26], [4, 5, 1, 3], [32, 35, 37, 39], [1000, 1001, 857, 1]]) ⇒ [27,5,39,1001]

</script>

</body>
</html>